# Templates

Templates are `.lg` and `.schema` files used to add additional logic and language generation to the dialog generation process. For most purposes the standard templates do everything needed and you will not need to create your own.

Current functionality in the [standard templates](../generator/templates) includes:

- Generating .lg, .lu and .dialog files that robustly handle out of order and
  multiple responses for simple and array properties.
- Add, remove, clear and show for properties.
- Support for choosing between ambiguous entity values and entity property mappings.
- Recognizing and mapping all LUIS prebuilt entities.
- Help including auto-help on multiple retries.
- Cancel
- Confirmation

## LUIS Prebuilt Entities

You can use the entities below when defining your properties.

- [age.schema](age.schema) LUIS prebuilt `age`.
- [datetime.schema](datetime.schema) LUIS prebuilt `datetimeV2`.
- [dimension.schema](dimension.schema) LUIS prebuilt `dimension`.
- [geography.schema](geography.schema) LUIS prebuilt `geographyV2`.
- [money.schema](money.schema) LUIS prebuilt `money`.
- [ordinal.schema](ordinal.schema) LUIS prebuilt `ordinalV2`.
- [temperature.schema](temperature.schema) LUIS prebuilt `temperature`.

## Writing Templates

You do not need to write or even understand templates in order to use generated dialogs.
Writing your own templates provide an opportunity to completely customize the generation process by extending or replacing the standard templates.
The templates themselves make use of the botbuilder-lg library to do the generation.

Each entity or property can have associated .lu, .lg, .qna and .dialog files
that are generated by copying or instantiating templates found in the template
directories. If a template name matches exactly it is just copied. If the
template ends with .lg then it is analyzed to check for these template names:

- **filename** Define the filename to generate.
- **template** Define the content of the file.
- **entities** If a property does not have an explicit `$entities` defined, this provides a default one.
- **templates** A list of other templates to look for. If the resulting filename is found explicitly in a template directory, then that replaces the  generated file.
  This provides the ability to override generated files for specific properties.

When evaluating templates there are a number of variables defined in the scope including:

- **prefix** Prefix to use for generated files.
- **appSchema** The path to the app.schema to use.
- **schema** The full JSON Schema including the root schema + internal
  properties.
- **locales** The list of all locales being generated.
- **properties** All of the $public property names.
- **entities** All of the entities being used in the schema.
- **triggerIntent** \$triggerIntent or the schema name by default.
- **locale** The locale being generated.
- **property** Current property being generated.
- **templates** Object with generated templates per lu, lg, qna, json and
  dialog. The object contains:
  - **name** Base name of the template without final extension.
  - **fallbackName** For .lg files the base filename without locale.
  - **fullName** The name of the template including the extension.
  - **relative** Path relative to the output directory of where template is.

The generation process at a high-level:

- Evaluate schema expressions and expand them if possible.  (It may not be possible because it depends on generated information.)
- Per-locale
  - Per-property
    - Look for `<propertyType>.lg` which usually defines `# entities` and `#
      templates`.
    - Per-template in the property schema `$templates` or in `# templates`
      generate .lg, .lu, .qna, .dialog files.
  - Evaluate templates defined in the schema root level `\$templates` of the
    merged schema.
- Evaluate schema expressions and write the full schema out to
  `<prefix>.schema.dialog`.

All generated assets are named using a standard pattern which is what enables
updating generated files when changing the schema. In the below, $italics$ are
place holders.

- `$schema$-library` -- Defines library files that are either common building
  blocks like [library.lg.lg](templates/library.lg.lg) or are internal
  mechanisms like [library-help.lg.lg](templates/library-Help.lg.lg).
- `$schema$-$entity$Entity` -- Defines entity specific files.
- `$schema$-$property$` -- Defines property related files when $property$ is found
  in the schema.
- `$locale$/` -- Assets for a particular locale that follows the above naming
  patterns and adds `$locale$` to the file extension, an example would be
  `en-us/sandwich-Bread.en-us.lg` which would be a localized `.lg` asset for the
  `Bread` property in the `sandwich` schema. You can define your own templates
  that add to the naming conventions, but they must extend these conventions.

## Documentation Index

1. [Get started][start]
1. Working with schema
    1. [Writing schemas][schema]
    1. [Sample schemas][sample-schemas]
1. Working with templates
    1. [Writing templates][templates-overview]
    1. [Pre-built templates][templates]
1. [Presentation (pptx)](2020%20Feb%20MVP%20Generated%20Dialogs.pptx)
1. [White paper (docx)](Generating%20Dialogs%20from%20Schema,%20APIs%20and%20Databases.docx)

[schema]:bot-schema.md
[templates]:../generator/templates
[templates-overview]:templates.md
[start]:get-stared.md
[sample-schemas]:example-schemas
